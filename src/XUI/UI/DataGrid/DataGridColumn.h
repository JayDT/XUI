/*
* Copyright (C) 2017-2018 Tauri JayD <https://www.>
*
* This program is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License as published by the
* Free Software Foundation; either version 2 of the License, or (at your
* option) any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License along
* with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __XUI_DATAGRID_COLUMN_H__
#define __XUI_DATAGRID_COLUMN_H__

#include "Core/Dependencies/DependencyObject.h"
#include "UI/Detail/GridLength.h"
#include "UI/DataGrid/DataGridDefines.h"

MetaAssemblyBegin
Meta(modul: ReflInclude("UI/DataGrid/DataGridCell.h"))
MetaAssemblyEnd

namespace XUI::UI
{
    class DataGrid;
    class DataGridCell;

    class DataGridColumn : public Core::Dependency::DependencyObject
    {
    public:

        static Core::Dependency::RefDependencyProperty HeaderProperty;
        static Core::Dependency::RefDependencyProperty HeaderStyleProperty;
        static Core::Dependency::RefDependencyProperty HeaderStringFormatProperty;
        static Core::Dependency::RefDependencyProperty HeaderTemplateProperty;
        static Core::Dependency::RefDependencyProperty CellStyleProperty;
        static Core::Dependency::RefDependencyProperty CellTemplateProperty;
        static Core::Dependency::RefDependencyProperty IsReadOnlyProperty;
        static Core::Dependency::RefDependencyProperty WidthProperty;
        static Core::Dependency::RefDependencyProperty MinWidthProperty;
        static Core::Dependency::RefDependencyProperty MaxWidthProperty;
        static Core::Dependency::RefDependencyProperty OriginalValueProperty; // Attach
        static Core::Dependency::RefDependencyProperty DisplayIndexProperty;
        static Core::Dependency::RefDependencyProperty CanUserSortProperty;
        static Core::Dependency::RefDependencyProperty CanUserReorderProperty;
        static Core::Dependency::RefDependencyProperty CanUserResizeProperty;
        static Core::Dependency::RefDependencyProperty SortDirectionProperty;
        static Core::Dependency::RefDependencyProperty IsFrozenProperty;
        static Core::Dependency::RefDependencyProperty CellValueProperty; // Attach
        static Core::Dependency::RefDependencyProperty VisibilityProperty;
        static Core::Dependency::RefDependencyProperty ElementStyleProperty;
        static Core::Dependency::RefDependencyProperty EditingElementStyleProperty;
        static Core::Dependency::RefDependencyProperty ActualWidthProperty;
        static Core::Dependency::RefDependencyProperty BindingProperty;

        static void StaticClassInitializer();

        DataGridColumn();
        virtual ~DataGridColumn();

#pragma region Data

        std::weak_ptr<DataGrid> _dataGridOwner;                     // This property is updated by DataGrid when the column is added to the DataGrid.Columns collection
        std::shared_ptr<XamlCPP::Interfaces::IBinding> _binding;
        //BindingBase _clipboardContentBinding;                     // Storage for ClipboardContentBinding
        bool _ignoreRedistributionOnWidthChange = false;            // Flag which indicates to ignore recomputation of column widths on width change of column
        bool _invalidatedStarWidth = false;
        bool _processingWidthChange = false;                        // Flag which indicates that execution of width change callback to avoid recursions.
		bool _isAutoGenerated = false;
        static constexpr double _starMaxWidth = 10000.0;            // Max Width constant for star columns
		double ActualWidth = 0.0;
		double DesiredWidth = 0.0;

#pragma endregion

		DataGrid* DataGridOwner() { return _dataGridOwner.lock().get(); }

        System::Events::EventHandler<Interfaces::DataGridCellClipboardEventArgs> CopyingCellClipboardContent;
        System::Events::EventHandler<Interfaces::DataGridCellClipboardEventArgs> PastingCellClipboardContent;

        PROPERTY_(System::Reflection::RefObject, Header);
        System::Reflection::RefObject GetHeader() const { return GetValue<System::Reflection::RefObject>(HeaderProperty); }
        void SetHeader(System::Reflection::RefObject const& value) { SetValue(HeaderProperty, value); }

        PROPERTY_(std::shared_ptr<XUI::Styling::Style>, HeaderStyle);
        std::shared_ptr<XUI::Styling::Style> GetHeaderStyle() const { return GetValue<std::shared_ptr<XUI::Styling::Style>>(HeaderStyleProperty); }
        void SetHeaderStyle(std::shared_ptr<XUI::Styling::Style> const& value) { SetValue(HeaderStyleProperty, value); }

        PROPERTY_(std::string, HeaderStringFormat);
        std::string GetHeaderStringFormat() const { return GetValue<std::string>(HeaderStringFormatProperty); }
        void SetHeaderStringFormat(std::string const& value) { SetValue(HeaderStringFormatProperty, value); }

        PROPERTY_(std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate>, HeaderTemplate);
        std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate> GetHeaderTemplate() const { return GetValue<std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate>>(HeaderTemplateProperty); }
        void SetHeaderTemplate(std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate> const& value) { SetValue(HeaderTemplateProperty, value); }

        PROPERTY_(std::shared_ptr<XUI::Styling::Style>, CellStyle);
        std::shared_ptr<XUI::Styling::Style> GetCellStyle() const { return GetValue<std::shared_ptr<XUI::Styling::Style>>(CellStyleProperty); }
        void SetCellStyle(std::shared_ptr<XUI::Styling::Style> const& value) { SetValue(CellStyleProperty, value); }

        PROPERTY_(std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate>, CellTemplate);
        std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate> GetCellTemplate() const { return GetValue<std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate>>(CellTemplateProperty); }
        void SetCellTemplate(std::shared_ptr<XUI::UI::DataTemplates::ContentTemplate> const& value) { SetValue(CellTemplateProperty, value); }

        PROPERTY_(std::shared_ptr<XUI::Styling::Style>, ElementStyle);
        std::shared_ptr<XUI::Styling::Style> GetElementStyle() const { return GetValue<std::shared_ptr<XUI::Styling::Style>>(ElementStyleProperty); }
        void SetElementStyle(std::shared_ptr<XUI::Styling::Style> const& value) { SetValue(ElementStyleProperty, value); }

        PROPERTY_(std::shared_ptr<XUI::Styling::Style>, EditingElementStyle);
        std::shared_ptr<XUI::Styling::Style> GetEditingElementStyle() const { return GetValue<std::shared_ptr<XUI::Styling::Style>>(EditingElementStyleProperty); }
        void SetEditingElementStyle(std::shared_ptr<XUI::Styling::Style> const& value) { SetValue(EditingElementStyleProperty, value); }

        bool GetIsReadOnly() const { return GetValue<bool>(IsReadOnlyProperty); }
        void SetIsReadOnly(bool const& value) { SetValue(IsReadOnlyProperty, value); }

        PROPERTY_(XUI::UI::GridLength, Width);
        XUI::UI::GridLength GetWidth() const { return GetValue<XUI::UI::GridLength>(WidthProperty.get()); }
        void SetWidth(XUI::UI::GridLength const& value) { SetValue(WidthProperty.get(), value); }

        PROPERTY_(double, MinWidth);
        double GetMinWidth() const { return GetValue<double>(MinWidthProperty); }
        void SetMinWidth(double const& value) { SetValue(MinWidthProperty, value); }

        PROPERTY_(double, MaxWidth);
        double GetMaxWidth() const { return GetValue<double>(MaxWidthProperty); }
        void SetMaxWidth(double const& value) { SetValue(MaxWidthProperty, value); }

        PROPERTY_(int, DisplayIndex);
        int GetDisplayIndex() const { return GetValue<int>(DisplayIndexProperty); }
        void SetDisplayIndex(int const& value) { SetValue(DisplayIndexProperty, value); }

        PROPERTY_(bool, CanUserSort);
        bool GetCanUserSort() const { return GetValue<bool>(CanUserSortProperty); }
        void SetCanUserSort(bool const& value) { SetValue(CanUserSortProperty, value); }

        PROPERTY_(ListSortDirection, SortDirection);
        ListSortDirection GetSortDirection() const { return GetValue<ListSortDirection>(SortDirectionProperty); }
        void SetSortDirection(ListSortDirection const& value) { SetValue(SortDirectionProperty, value); }

        PROPERTY_(bool, IsFrozen);
        bool GetIsFrozen() const { return GetValue<bool>(IsFrozenProperty); }
        void SetIsFrozen(bool const& value) { SetValue(IsFrozenProperty, value); }

        PROPERTY_(bool, CanUserReorder);
        bool GetCanUserReorder() const { return GetValue<bool>(CanUserReorderProperty); }
        void SetCanUserReorder(bool const& value) { SetValue(CanUserReorderProperty, value); }

        PROPERTY_(bool, CanUserResize);
        bool GetCanUserResize() const { return GetValue<bool>(CanUserResizeProperty); }
        void SetCanUserResize(bool const& value) { SetValue(CanUserResizeProperty, value); }

        PROPERTY_(UI::Visibility, Visibility);
        UI::Visibility GetVisibility() const { return GetValue<UI::Visibility>(VisibilityProperty); }
        void SetVisibility(UI::Visibility const& value) { SetValue(VisibilityProperty, value); }

        Meta(XamlCPP::AssignBindingAttribute())
        PROPERTY_(std::shared_ptr<XamlCPP::Interfaces::IBinding>, Binding);
        std::shared_ptr<XamlCPP::Interfaces::IBinding> const& GetBinding() const { return _binding; }
        void SetBinding(std::shared_ptr<XamlCPP::Interfaces::IBinding> const& value) { SetAndRaise(BindingProperty, _binding, value); }

        //DEPENDENCY_PROPERTY_(std::shared_ptr<XUI::Styling::Style>, DragIndicatorStyle)

		bool IsVisible() const { return Visibility == UI::Visibility::Visible; }

        std::shared_ptr<XUI::UI::Controls::Control> BuildVisualTree(bool isEditing, System::Reflection::Variant const& dataItem, XUI::UI::DataGridCell* cell);

        static System::Reflection::Variant GetOriginalValue(Core::Dependency::DependencyObject* obj) { return obj->GetValue(OriginalValueProperty.get()); }
        static void SetOriginalValue(Core::Dependency::DependencyObject* obj, System::Reflection::Variant const& value) { obj->SetValue(OriginalValueProperty, value); }
        static void ClearOriginalValue(Core::Dependency::DependencyObject* obj) { obj->ClearValue(OriginalValueProperty.get()); }

        static System::Reflection::Variant GetCellValue(Core::Dependency::DependencyObject* obj) { return obj->GetValue(CellValueProperty.get()); }
        static void SetCellValue(Core::Dependency::DependencyObject* obj, System::Reflection::Variant const& value) { obj->SetValue(CellValueProperty, value); }
        static void ClearCellValue(Core::Dependency::DependencyObject* obj) { obj->ClearValue(CellValueProperty.get()); }

        void NotifyPropertyChanged(Core::Dependency::DependencyObject* d, Core::Dependency::DependencyPropertyChangedEventArgs& e, NotificationTarget target);

        static void OnWidthPropertyChanged(XamlCPP::Core::Dependency::IDependencyObject* d, Core::Dependency::DependencyPropertyChangedEventArgs& e);
        static void OnActualWidthPropertyChanged(XamlCPP::Core::Dependency::IDependencyObject* d, Core::Dependency::DependencyPropertyChangedEventArgs& e);

        /// <summary>
        ///     Retrieve the proper measure constraint for cells.
        /// </summary>
        /// <param name="isHeader">Whether a header constraint or a normal cell constraint is requested.</param>
        /// <returns>The value to use as the width when creating a measure constraint.</returns>
        double GetConstraintWidth(bool isHeader);

#pragma region Editing

    protected:
        /// <summary>
        ///     Called when a cell has just switched to edit mode.
        /// </summary>
        /// <param name="editingElement">A reference to element returned by GenerateEditingElement.</param>
        /// <returns>The unedited value of the cell.</returns>
        virtual System::Reflection::Variant PrepareCellForEdit(XUI::UI::Controls::Control* editingElement, Core::Observer::RoutedEventArgs& editingEventArgs)
        {
            return System::Reflection::Variant::Empty;
        }

        /// <summary>
        ///     Called when a cell's value is to be restored to its original value,
        ///     just before it exits edit mode.
        /// </summary>
        /// <param name="editingElement">A reference to element returned by GenerateEditingElement.</param>
        /// <param name="uneditedValue">The original, unedited value of the cell.</param>
        virtual void CancelCellEdit(XUI::UI::Controls::Control* editingElement, System::Reflection::Variant& uneditedValue)
        {
        }

        /// <summary>
        ///     Called when a cell's value is to be committed, just before it exits edit mode.
        /// </summary>
        /// <param name="editingElement">A reference to element returned by GenerateEditingElement.</param>
        /// <returns>false if there is a validation error. true otherwise.</returns>
        virtual bool CommitCellEdit(XUI::UI::Controls::Control* editingElement)
        {
            return true;
        }

    public:
        void BeginEdit(XUI::UI::Controls::Control* editingElement, Core::Observer::RoutedEventArgs& e)
        {
            // This call is to ensure that the tree and its bindings have resolved
            // before we proceed to code that relies on the tree being ready.
            if (editingElement != nullptr)
            {
                //editingElement->UpdateLayout();

                auto originalValue = PrepareCellForEdit(editingElement, e);
                SetOriginalValue(editingElement, originalValue);
            }
        }

        void CancelEdit(XUI::UI::Controls::Control* editingElement)
        {
            if (editingElement != nullptr)
            {
                CancelCellEdit(editingElement, GetOriginalValue(editingElement));
                ClearOriginalValue(editingElement);
            }
        }

        
        bool CommitEdit(XUI::UI::Controls::Control* editingElement)
        {
            if (editingElement != nullptr)
            {
                if (CommitCellEdit(editingElement))
                {
                    // Validation passed
                    ClearOriginalValue(editingElement);
                    return true;
                }
                else
                {
                    // Validation failed. This cell will remain in edit mode.
                    return false;
                }
            }

            return true;
        }

#pragma endregion


        /// <summary>
        /// Helper Method which creates a default DataGridColumn object for the specified property type.
        /// </summary>
        /// <param name="itemProperty"></param>
        /// <returns></returns>
        static std::shared_ptr<DataGridColumn> CreateDefaultColumn(System::Reflection::Field const* itemProperty);

        /// <summary>
        /// This method is called for each selected cell in each selected cell to retrieve the default cell content.
        /// Default cell content is calculated using ClipboardContentBinding.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        virtual System::Reflection::Variant OnCopyingCellClipboardContent(System::Reflection::Variant const& item);

        /// We don't provide default Paste but this public method is exposed to help custom implementation of Paste
        /// <summary>
        /// This method stores the cellContent into the item object using ClipboardContentBinding.
        /// </summary>
        /// <param name="item"></param>
        /// <param name="cellContent"></param>
        virtual void OnPastingCellClipboardContent(System::Reflection::Variant const& item, System::Reflection::Variant const& cellContent);

        virtual void OnInput(Core::Observer::RoutedEventArgs const& e);

        void BeginEdit(Core::Observer::RoutedEventArgs const& e);

		/// <summary>
		/// Internal method which sets the column's width
		/// without actual redistribution of widths among other
		/// columns
		/// </summary>
		/// <param name="width"></param>
		void SetWidthInternal(GridLength const& width, double actualWidth, double desiredWidth)
		{
			bool originalValue = _ignoreRedistributionOnWidthChange;
			_ignoreRedistributionOnWidthChange = true;
			try
			{
				Width = width;
				DesiredWidth = desiredWidth;
                SetAndRaise(ActualWidthProperty, ActualWidth, actualWidth);
			}
			catch (...)
			{

			}
			_ignoreRedistributionOnWidthChange = originalValue;
		}

        void UpdateWidthForStarColumn(double displayWidth, double desiredWidth, double starValue)
        {
            ASSERT(Width.IsStar);

            if (displayWidth != ActualWidth || desiredWidth != DesiredWidth || Width.Value != starValue)
            {
                SetWidthInternal(Width, displayWidth, desiredWidth);
            }
        }

        void SyncProperties();

        /// <summary>
        /// Override which rebuilds the cell's visual tree for Binding change
        /// </summary>
        /// <param name="element"></param>
        /// <param name="propertyName"></param>
        virtual void RefreshCellContent(XUI::UI::Controls::Control* element, std::string propertyName);

    protected:
        virtual std::shared_ptr<XUI::UI::Controls::Control> GenerateElement(DataGridCell* cell, System::Reflection::Variant const& dataItem) = 0;
        virtual std::shared_ptr<XUI::UI::Controls::Control> GenerateEditingElement(DataGridCell* cell, System::Reflection::Variant const& dataItem) = 0;
    };
}

#endif // !__XUI_DATAGRID_COLUMN_H__
